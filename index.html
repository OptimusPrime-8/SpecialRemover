<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clean Word Document and Download</title>
</head>
<body>
<input type="file" id="wordFile" accept=".docx">
<button id="uploadBtn">Upload</button>
<button id="processBtn">Process</button>
<button id="downloadBtn">Download</button>

<!-- Using more recent and stable versions of the libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.0/mammoth.browser.min.js"></script>
<script src="https://unpkg.com/docx@8.5.0/build/index.js"></script>

<script>
console.log("Scripts loaded. Waiting for user action.");

const charMap = {
    "à": "a", "À": "A",
    "è": "e", "È": "E",
    "é": "e", "É": "E",
    "ì": "i", "Ì": "I",
    "ò": "o", "Ò": "O",
    "ù": "u", "Ù": "U",
    "—": ", "
};
const exceptionalWords = new Set(["μ","µ"]);

let uploadedContent = [];
let processedContent = [];

function cleanText(text) {
    if(exceptionalWords.has(text.trim())) return text;
    let newText = text;
    for(const [k,v] of Object.entries(charMap)) {
        newText = newText.split(k).join(v);
    }
    newText = newText.split('').map(ch => (/[\x00-\x7F]/.test(ch) || ch==='•'||ch===',') ? ch : '').join('');
    return newText;
}

async function extractWordContent(file) {
    console.log("Reading file content...");
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function() {
            mammoth.convertToHtml({ arrayBuffer: reader.result })
                .then(result => {
                    console.log("File content converted to HTML.");
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = result.value;
                    const paragraphs = Array.from(tempDiv.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li'));
                    const content = paragraphs.map(p => {
                        // Check for bold styling more reliably
                        const isBold = p.style.fontWeight === 'bold' || p.closest('strong') !== null;
                        const isItalic = p.style.fontStyle === 'italic' || p.closest('em') !== null;
                        return {
                            text: p.textContent || '',
                            tag: p.tagName.toLowerCase(),
                            bold: isBold,
                            italic: isItalic
                        };
                    });
                    console.log("Extracted paragraphs:", content.length);
                    resolve(content);
                })
                .catch(err => {
                    console.error("Mammoth.js error:", err);
                    reject(err);
                });
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
}

// Upload
document.getElementById('uploadBtn').addEventListener('click', async () => {
    const file = document.getElementById('wordFile').files[0];
    if (!file) return alert("Please select a Word file first.");
    try {
        uploadedContent = await extractWordContent(file);
        alert("File uploaded successfully! Ready to be processed.");
    } catch (err) {
        alert("Error reading Word file. Check the console for details.");
    }
});

// Process
document.getElementById('processBtn').addEventListener('click', () => {
    if (uploadedContent.length === 0) return alert("Please upload a file first.");
    console.log("Processing text...");
    processedContent = uploadedContent.map(p => ({...p, text: cleanText(p.text)}));
    console.log("Text processing complete.");
    alert("Text processed successfully! Ready to be downloaded.");
});

// ** MAJOR CORRECTION IS HERE **
// This function correctly maps HTML tags (h1, h2) to the format docx.js requires.
function getHeadingLevel(tag) {
    switch (tag) {
        case 'h1': return docx.HeadingLevel.HEADING_1;
        case 'h2': return docx.HeadingLevel.HEADING_2;
        case 'h3': return docx.HeadingLevel.HEADING_3;
        case 'h4': return docx.HeadingLevel.HEADING_4;
        case 'h5': return docx.HeadingLevel.HEADING_5;
        case 'h6': return docx.HeadingLevel.HEADING_6;
        default: return undefined;
    }
}

// Download
document.getElementById('downloadBtn').addEventListener('click', async () => {
    if (processedContent.length === 0) return alert("Please process the file first.");
    console.log("Starting download process...");

    try {
        const docChildren = processedContent.map(p => {
            return new docx.Paragraph({
                // Using the corrected heading function
                heading: getHeadingLevel(p.tag),
                bullet: p.tag === 'li' ? { level: 0 } : undefined,
                children: [
                    new docx.TextRun({
                        text: p.text,
                        bold: p.bold,
                        italics: p.italic,
                        font: "Times New Roman"
                    })
                ]
            });
        });

        console.log("Creating docx.Document object...");
        const doc = new docx.Document({
            sections: [{
                properties: {},
                children: docChildren
            }]
        });

        console.log("Generating file blob...");
        const blob = await docx.Packer.toBlob(doc);
        console.log("Blob created successfully. Triggering download.");

        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "Write_Analyzed.docx";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);
        console.log("Download should have started.");

    } catch (err) {
        console.error("Error generating Word file:", err);
        alert("An error occurred while creating the .docx file. Please check the developer console (F12) for details.");
    }
});
</script>
</body>
</html>