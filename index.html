<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clean Word Document and Download</title>
</head>
<body>
<input type="file" id="wordFile" accept=".docx">
<button id="uploadBtn">Upload</button>
<button id="processBtn">Process</button>
<button id="downloadBtn">Download</button>

<!-- 
    CRITICAL FIXES:
    1. The 'defer' attribute on both external script tags. This ensures they load in the background
       and execute AFTER the HTML is parsed, but before your main script.
    2. Your entire inline script is wrapped in 'DOMContentLoaded' (see below). This guarantees
       that 'docx' and 'mammoth' are fully ready before your code tries to use them.
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.0/mammoth.browser.min.js" defer></script>
<script src="https://unpkg.com/docx@8.5.0/build/index.js" defer></script>

<script>
// IMPORTANT: This ensures your JavaScript code runs only AFTER the HTML is fully loaded AND
// all 'defer'-ed scripts (like mammoth.js and docx.js) have finished executing.
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM and scripts loaded. Waiting for user action.");

    // Now, 'docx' is guaranteed to be defined, so we can safely destructure its components.
    const { Document, Packer, Paragraph, TextRun, HeadingLevel } = docx;

    // Character replacement map
    const charMap = {
        "à": "a", "À": "A", "è": "e", "È": "E", "é": "e", "É": E",
        "ì": "i", "Ì": "I", "ò": "o", "Ò": "O", "ù": "u", "Ù": "U", "—": ", "
    };
    // Words to exclude from cleaning
    const exceptionalWords = new Set(["μ","µ"]);

    let uploadedContent = [];
    let processedContent = [];

    // Function to clean the text from a single paragraph
    function cleanText(text) {
        if(exceptionalWords.has(text.trim())) return text;
        let newText = text;
        for(const [k,v] of Object.entries(charMap)) {
            newText = newText.split(k).join(v);
        }
        // Removes non-standard characters, but keeps bullets and commas
        newText = newText.split('').map(ch => (/[\x00-\x7F]/.test(ch) || ch==='•'||ch===',') ? ch : '').join('');
        return newText;
    }

    // Function to read the .docx file and extract its content
    async function extractWordContent(file) {
        console.log("Reading file content...");
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function() {
                mammoth.convertToHtml({ arrayBuffer: reader.result })
                    .then(result => {
                        console.log("File content converted to HTML.");
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = result.value;
                        const paragraphs = Array.from(tempDiv.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li'));
                        const content = paragraphs.map(p => ({
                            text: p.textContent || '',
                            tag: p.tagName.toLowerCase(),
                            bold: p.style.fontWeight === 'bold' || p.closest('strong') !== null,
                            italic: p.style.fontStyle === 'italic' || p.closest('em') !== null
                        }));
                        console.log("Extracted paragraphs:", content.length);
                        resolve(content);
                    })
                    .catch(err => {
                        console.error("Mammoth.js error during conversion:", err);
                        reject(err);
                    });
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    // --- Event Listeners for Buttons ---

    // 1. Upload Button
    document.getElementById('uploadBtn').addEventListener('click', async () => {
        const file = document.getElementById('wordFile').files[0];
        if (!file) return alert("Please select a Word file first.");
        try {
            uploadedContent = await extractWordContent(file);
            alert("File uploaded successfully! Ready to be processed.");
        } catch (err) {
            alert("Error reading Word file. Check the browser console (F12) for details.");
        }
    });

    // 2. Process Button
    document.getElementById('processBtn').addEventListener('click', () => {
        if (uploadedContent.length === 0) return alert("Please upload a file first.");
        console.log("Processing text...");
        processedContent = uploadedContent.map(p => ({...p, text: cleanText(p.text)}));
        console.log("Text processing complete.");
        alert("Text processed successfully! Ready to be downloaded.");
    });

    // Function to convert HTML heading tags (h1, h2) to Word heading styles
    function getHeadingLevel(tag) {
        switch (tag) {
            case 'h1': return HeadingLevel.HEADING_1;
            case 'h2': return HeadingLevel.HEADING_2;
            case 'h3': return HeadingLevel.HEADING_3;
            case 'h4': return HeadingLevel.HEADING_4;
            case 'h5': return HeadingLevel.HEADING_5;
            case 'h6': return HeadingLevel.HEADING_6;
            default: return undefined; // For 'p', 'li', etc., it will be a normal paragraph
        }
    }

    // 3. Download Button
    document.getElementById('downloadBtn').addEventListener('click', async () => {
        if (processedContent.length === 0) return alert("Please process the file first.");
        console.log("Starting download process...");

        try {
            // Filter out any empty paragraphs (after cleaning) to prevent docx.js errors
            const validContent = processedContent.filter(p => p.text.trim() !== '');
            console.log(`Generating document with ${validContent.length} valid paragraphs.`);

            const docChildren = validContent.map(p => {
                return new Paragraph({
                    heading: getHeadingLevel(p.tag), // Apply Word's built-in heading styles if detected
                    bullet: p.tag === 'li' ? { level: 0 } : undefined, // Apply bullet if it was a list item
                    children: [
                        new TextRun({
                            text: p.text,
                            bold: p.bold,
                            italics: p.italic,
                            // REMOVED: No hardcoded 'font' property to preserve original styling
                        })
                    ]
                });
            });
            
            // Create a new document with the processed content
            const doc = new Document({
                sections: [{
                    properties: {},
                    children: docChildren
                }]
            });
            
            console.log("Generating file blob...");
            const blob = await Packer.toBlob(doc);
            console.log("Blob created successfully. Triggering download.");
            
            // Create a temporary link to trigger the download
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = "Write_Analyzed.docx"; // Desired filename
            document.body.appendChild(link);
            link.click(); // Programmatically click the link to start download
            document.body.removeChild(link); // Remove the link
            URL.revokeObjectURL(link.href); // Clean up the object URL
            console.log("Download should have started.");

        } catch (err) {
            console.error("An error occurred while generating the .docx file. Details:", err);
            alert("An error occurred while creating the .docx file. Please check the browser console (F12) for more details.");
        }
    });
});
</script>
</body>
</html>