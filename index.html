<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clean Word Document and Download</title>
</head>
<body>
<input type="file" id="wordFile" accept=".docx">
<button id="uploadBtn">Upload</button>
<button id="processBtn">Process</button>
<button id="downloadBtn">Download</button>

<!-- External libraries for reading and creating Word documents -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.0/mammoth.browser.min.js"></script>
<script src="https://unpkg.com/docx@8.5.0/build/index.js"></script>

<script>
// This ensures all components from the 'docx' library are loaded and ready before you click any buttons.
const { Document, Packer, Paragraph, TextRun, HeadingLevel } = docx;

console.log("Scripts loaded. Waiting for user action.");

// Character replacement map
const charMap = {
    "à": "a", "À": "A", "è": "e", "È": "E", "é": "e", "É": "E",
    "ì": "i", "Ì": "I", "ò": "o", "Ò": "O", "ù": "u", "Ù": "U", "—": ", "
};
// Words to exclude from cleaning
const exceptionalWords = new Set(["μ","µ"]);

let uploadedContent = [];
let processedContent = [];

// Function to clean the text from a single paragraph
function cleanText(text) {
    if(exceptionalWords.has(text.trim())) return text;
    let newText = text;
    for(const [k,v] of Object.entries(charMap)) {
        newText = newText.split(k).join(v);
    }
    // Removes non-standard characters, but keeps bullets and commas
    newText = newText.split('').map(ch => (/[\x00-\x7F]/.test(ch) || ch==='•'||ch===',') ? ch : '').join('');
    return newText;
}

// Function to read the .docx file and extract its content
async function extractWordContent(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function() {
            mammoth.convertToHtml({ arrayBuffer: reader.result })
                .then(result => {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = result.value;
                    const paragraphs = Array.from(tempDiv.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li'));
                    const content = paragraphs.map(p => ({
                        text: p.textContent || '',
                        tag: p.tagName.toLowerCase(),
                        bold: p.style.fontWeight === 'bold' || p.closest('strong') !== null,
                        italic: p.style.fontStyle === 'italic' || p.closest('em') !== null
                    }));
                    resolve(content);
                })
                .catch(err => reject(err));
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
    });
}

// --- Event Listeners for Buttons ---

// 1. Upload Button
document.getElementById('uploadBtn').addEventListener('click', async () => {
    const file = document.getElementById('wordFile').files[0];
    if (!file) return alert("Please select a Word file first.");
    try {
        uploadedContent = await extractWordContent(file);
        alert("File uploaded successfully! Ready to be processed.");
    } catch (err) {
        console.error("Error reading file:", err);
        alert("Error reading Word file. Check the console for details.");
    }
});

// 2. Process Button
document.getElementById('processBtn').addEventListener('click', () => {
    if (uploadedContent.length === 0) return alert("Please upload a file first.");
    processedContent = uploadedContent.map(p => ({...p, text: cleanText(p.text)}));
    alert("Text processed successfully! Ready to be downloaded.");
});

// Function to convert HTML heading tags (h1, h2) to Word heading styles
function getHeadingLevel(tag) {
    switch (tag) {
        case 'h1': return HeadingLevel.HEADING_1;
        case 'h2': return HeadingLevel.HEADING_2;
        case 'h3': return HeadingLevel.HEADING_3;
        case 'h4': return HeadingLevel.HEADING_4;
        case 'h5': return HeadingLevel.HEADING_5;
        case 'h6': return HeadingLevel.HEADING_6;
        default: return undefined;
    }
}

// 3. Download Button
document.getElementById('downloadBtn').addEventListener('click', async () => {
    if (processedContent.length === 0) return alert("Please process the file first.");

    try {
        // Filter out any empty paragraphs to prevent errors
        const validContent = processedContent.filter(p => p.text.trim() !== '');

        const docChildren = validContent.map(p => {
            return new Paragraph({
                heading: getHeadingLevel(p.tag),
                bullet: p.tag === 'li' ? { level: 0 } : undefined,
                children: [
                    new TextRun({
                        text: p.text,
                        bold: p.bold,
                        italics: p.italic,
                        font: "Times New Roman"
                    })
                ]
            });
        });

        // Create a new document with the processed content
        const doc = new Document({
            sections: [{
                properties: {},
                children: docChildren
            }]
        });

        // Pack the document into a blob and trigger the download
        const blob = await Packer.toBlob(doc);
        
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = "Write_Analyzed.docx";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

    } catch (err) {
        console.error("An error occurred while generating the .docx file:", err);
        alert("An error occurred while creating the .docx file. Please check the developer console (F12) for more details.");
    }
});
</script>
</body>
</html>