<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Clean Word Document</title>
<style>
    body { font-family: sans-serif; margin: 20px; }
    button { margin: 5px; padding: 8px 12px; cursor: pointer; }
    button:disabled { cursor: not-allowed; background-color: #e0e0e0; color: #888; }
    #loader { font-style: italic; color: #555; font-weight: bold; }
    #preview-container {
        margin-top: 25px;
        border: 1px solid #ccc;
        padding: 15px;
        max-height: 400px;
        overflow-y: auto;
        background-color: #f9f9f9;
    }
    .preview-paragraph { margin-bottom: 10px; }
</style>
</head>
<body>

<h2>Clean and Download Word Document</h2>
<p id="loader">Loading libraries, please wait...</p>

<input type="file" id="wordFile" accept=".docx">
<br><br>
<button id="uploadBtn" disabled>1. Upload</button>
<button id="processBtn" disabled>2. Process & Preview</button>
<button id="downloadBtn" disabled>3. Download "Write_Analyzed.docx"</button>

<div id="preview-container" style="display: none;">
    <h3>Processed Content Preview:</h3>
    <div id="preview-content"></div>
</div>

<!-- These scripts will load in the background. The code will wait for them. -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.7.0/mammoth.browser.min.js"></script>
<script src="https://unpkg.com/docx@8.5.0/build/index.js"></script>

<script>
// --- ROBUST LIBRARY LOADER ---
// This function waits until it confirms the 'mammoth' and 'docx' libraries are ready.
function initializeAppWhenReady() {
    if (typeof mammoth !== 'undefined' && typeof docx !== 'undefined') {
        
        console.log("SUCCESS: Libraries are loaded and ready.");
        document.getElementById('loader').textContent = "Ready. Please select a file.";
        
        // Now it's safe to run the main application logic.
        setupApplicationLogic();

    } else {
        // If not ready, wait 100 milliseconds and check again.
        setTimeout(initializeAppWhenReady, 100);
    }
}

// --- MAIN APPLICATION LOGIC ---
// This function only runs AFTER the libraries are confirmed to be loaded.
function setupApplicationLogic() {
    
    // It is now 100% safe to use the 'docx' object.
    const { Document, Packer, Paragraph, TextRun } = docx;

    // Enable all the buttons for the user.
    document.getElementById('uploadBtn').disabled = false;
    document.getElementById('processBtn').disabled = false;
    document.getElementById('downloadBtn').disabled = false;

    const charMap = {
        "à": "a", "À": "A", "è": "e", "È": "E", "é": "e", "É": "E",
        "ì": "i", "Ì": "I", "ò": "o", "Ò": "O", "ù": "u", "Ù": "U", "—": ", "
    };
    const exceptionalWords = new Set(["μ","µ"]);

    let uploadedContent = [];
    let processedContent = [];

    function cleanText(text) {
        if(exceptionalWords.has(text.trim())) return text;
        let newText = text;
        for(const [k,v] of Object.entries(charMap)) {
            newText = newText.split(k).join(v);
        }
        newText = newText.split('').map(ch => (/[\x00-\x7F]/.test(ch) || ch==='•'||ch===',') ? ch : '').join('');
        return newText;
    }

    async function extractWordContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function() {
                mammoth.convertToHtml({ arrayBuffer: reader.result })
                    .then(result => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = result.value;
                        const elements = Array.from(tempDiv.querySelectorAll('p, h1, h2, h3, h4, h5, h6, li'));
                        const content = elements.map(el => ({
                            text: el.textContent || '',
                            isList: el.tagName.toLowerCase() === 'li',
                            bold: el.style.fontWeight === 'bold' || el.closest('strong') !== null,
                            italic: el.style.fontStyle === 'italic' || el.closest('em') !== null
                        }));
                        resolve(content);
                    })
                    .catch(err => reject(err));
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    document.getElementById('uploadBtn').addEventListener('click', async () => {
        const file = document.getElementById('wordFile').files[0];
        if (!file) return alert("Please select a .docx file first.");
        try {
            uploadedContent = await extractWordContent(file);
            alert(`File "${file.name}" uploaded. Click 'Process & Preview'.`);
            document.getElementById('preview-container').style.display = 'none';
        } catch (err) {
            console.error("Error reading file:", err);
            alert("Error reading Word file. Check console (F12).");
        }
    });

    document.getElementById('processBtn').addEventListener('click', () => {
        if (uploadedContent.length === 0) return alert("Please upload a file first.");
        processedContent = uploadedContent.map(p => ({ ...p, text: cleanText(p.text) }));
        
        const previewContainer = document.getElementById('preview-container');
        const previewContent = document.getElementById('preview-content');
        previewContent.innerHTML = ""; // Clear previous

        processedContent.forEach(p => {
            if (p.text.trim() === "") return;
            const div = document.createElement('div');
            div.className = 'preview-paragraph';
            if (p.isList) {
                div.textContent = "• " + p.text;
                div.style.marginLeft = "20px";
            } else {
                div.textContent = p.text;
            }
            if (p.bold) div.style.fontWeight = 'bold';
            if (p.italic) div.style.fontStyle = 'italic';
            previewContent.appendChild(div);
        });

        previewContainer.style.display = 'block';
        alert("Processed. Review the preview below, then click 'Download'.");
    });

    document.getElementById('downloadBtn').addEventListener('click', async () => {
        if (processedContent.length === 0) return alert("Please 'Process' the file first.");
        try {
            const validContent = processedContent.filter(p => p.text.trim() !== '');
            if (validContent.length === 0) return alert("No content to download.");

            const docChildren = validContent.map(p => {
                return new Paragraph({
                    bullet: p.isList ? { level: 0 } : undefined,
                    children: [ new TextRun({ text: p.text, bold: p.bold, italics: p.italic }) ]
                });
            });

            const doc = new Document({ sections: [{ children: docChildren }] });
            
            const blob = await Packer.toBlob(doc);
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = "Write_Analyzed.docx";
            document.body.appendChild(link);
            link.click();
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }, 100);
        } catch (err) {
            console.error("Error generating file:", err);
            alert("Error during download. Check console (F12).");
        }
    });
}

// Start the entire process.
initializeAppWhenReady();
</script>

</body>
</html>